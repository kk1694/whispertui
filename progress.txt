# WhisperTUI Progress & Learnings

This file captures learnings and notes across Ralph Loop iterations.
Each Claude instance should read this at the start and append notes at the end.

---

## Learnings

### 2026-01-17: Step 1a - Project Init & XDG Paths

- Bun's `bun init` creates a working TypeScript setup quickly
- XDG Base Directory spec is straightforward: environment variables override defaults
- Bun's test runner (`bun test`) works well, supports describe/test/expect patterns
- The `ensureDir` helper with `{ recursive: true }` handles nested directory creation

### 2026-01-17: Step 1b - Config Schema & Loader

- Zod 4.x has breaking changes from Zod 3.x - `.default({})` on object schemas with inner defaults no longer works the same way
- Solution: Use a PartialConfigSchema with all optional fields, then deep merge with defaults
- The `@iarna/toml` package works well for TOML parsing
- Deep merge is needed for partial config objects to properly overlay onto defaults
- Test isolation with XDG paths: Set `XDG_CONFIG_HOME` to a temp directory, but ensure path structure matches what `getConfigPath()` expects

---

### 2026-01-17: Step 2a - State Machine

- Pure state machine with no I/O makes testing straightforward
- Used TypeScript discriminated unions for DaemonEvent type - provides good type safety
- InvalidTransitionError custom error class helps with debugging and programmatic error handling
- The `canTransition` method allows checking validity without throwing
- Event emitter pattern using Set<Listener> and returning unsubscribe function is clean
- Context object is immutable (getter returns copy) to prevent accidental mutations
- 34 unit tests covering all valid transitions, invalid transitions, error handling, context tracking, and event emitter

---

### 2026-01-17: Step 2b - Unix Socket Server & IPC

- Node.js `net` module works well for Unix sockets - use `createServer()` for server and `connect()` for client
- JSON newline-delimited protocol is simple and effective for IPC
- PID file management: Check if PID is running with `process.kill(pid, 0)` - returns without error if process exists
- Socket permissions: Use `chmodSync(socketPath, 0o600)` for owner read/write only
- Stale file cleanup must happen before binding to socket, otherwise EADDRINUSE
- TypeScript: Socket `data` event can receive `Buffer | string`, need to handle both types
- Signal handlers: Use `process.on("SIGTERM/SIGINT")` for graceful shutdown
- Server lifecycle: Important to clean up clients, socket file, and PID file on shutdown
- Test isolation: Use `XDG_STATE_HOME` env var pointing to temp directory with unique PID suffix
- 30 new tests covering socket server, JSON protocol, commands, PID management, and cleanup

### 2026-01-17: Step 3a - Socket Client

- Socket client uses `connect()` from `node:net` to connect to Unix socket
- Quick fail by checking socket file exists before attempting connection - saves time when daemon not running
- Custom error classes (DaemonNotRunningError, ConnectionTimeoutError) help with user-friendly error messages
- Socket error codes: ECONNREFUSED and ENOENT both indicate daemon not running
- Response buffering: Accumulate data chunks until newline found, then parse JSON
- Timeout handling with `setTimeout()` and cleanup function to avoid resource leaks
- Toggle command needs two round trips: status to check current state, then start or stop
- Test isolation: Same pattern as server tests - use XDG_STATE_HOME with temp directory
- Testing timeout: Create mock server that accepts connections but never responds
- 18 new tests covering client connection, command sending, error handling, and response formatting

### 2026-01-17: Step 3b - Daemon Auto-Start

- Spawn daemon using `spawn()` with `detached: true` and `stdio: ["ignore", "ignore", "ignore"]` for clean background process
- Added `DaemonStartError` custom error class for spawn/startup failures
- `isDaemonStarting()` check prevents race condition when multiple commands try to start daemon simultaneously
- `waitForDaemon()` polls with configurable timeout until daemon responds to ping
- `ensureDaemonRunning()` is the main entry point - returns boolean indicating if daemon was auto-started
- CLI commands now auto-start daemon transparently using `ensureDaemonRunning()` before sending commands
- TypeScript: Need to use `stdio: ["ignore", "ignore", "ignore"]` (array form) instead of `stdio: "ignore"` (string form) to avoid type errors with spawn
- TypeScript: Need to check `process.argv[1]` for undefined before using
- 8 new tests covering waitForDaemon, ensureDaemonRunning, spawnDaemon, and DaemonStartError

### 2026-01-17: Step 4 - Audio Recording

- Created `src/audio/recorder.ts` with `AudioRecorder` class wrapping parecord subprocess
- Custom error classes: `ParecordNotFoundError` (with install instructions for Arch/Ubuntu/Fedora), `RecordingError`
- parecord args: `--file-format=wav --rate=16000 --channels=1 --format=s16le` for 16kHz mono WAV
- Device selection: Use `--device=` arg when config device is not "default"
- Temp files stored in XDG cache directory (`~/.cache/whispertui/recording-<timestamp>.wav`)
- Recording timeout protection: `setTimeout()` auto-stops after max duration (default 5 minutes)
- Graceful shutdown: SIGTERM to parecord, with SIGKILL fallback after 2 seconds
- `abort()` method for canceling without saving (SIGKILL + file cleanup)
- File validation: Check file exists and has content after stop, reject empty files
- Integrated recording into `DaemonServer` - start/stop commands now trigger actual audio recording
- DaemonServerOptions pattern: Accept config to extract recording settings, or provide recordingConfig directly
- Duck-typing for backward compatibility: Check if argument has `state` and `send` to detect StateMachine vs options object
- `cleanupOldRecordings()` helper to prune old temp files from cache directory
- 26 new tests covering recorder lifecycle, error handling, config extraction, and cleanup

---

## Current State

- Project status: Step 4 complete
- Last completed task: Step 4 - Audio Recording
- Current blockers: None

---

## Notes for Next Iteration

- Next task: Step 5 - Groq API Integration
- Need to implement Groq API client for Whisper transcription
- Handle API key from `.env` file (GROQ_API_KEY)
- Parse transcription response and integrate with daemon
- Add error handling for rate limits, network errors, invalid audio
