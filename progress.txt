# WhisperTUI Progress & Learnings

This file captures learnings and notes across Ralph Loop iterations.
Each Claude instance should read this at the start and append notes at the end.

---

## Learnings

### 2026-01-17: Step 1a - Project Init & XDG Paths

- Bun's `bun init` creates a working TypeScript setup quickly
- XDG Base Directory spec is straightforward: environment variables override defaults
- Bun's test runner (`bun test`) works well, supports describe/test/expect patterns
- The `ensureDir` helper with `{ recursive: true }` handles nested directory creation

### 2026-01-17: Step 1b - Config Schema & Loader

- Zod 4.x has breaking changes from Zod 3.x - `.default({})` on object schemas with inner defaults no longer works the same way
- Solution: Use a PartialConfigSchema with all optional fields, then deep merge with defaults
- The `@iarna/toml` package works well for TOML parsing
- Deep merge is needed for partial config objects to properly overlay onto defaults
- Test isolation with XDG paths: Set `XDG_CONFIG_HOME` to a temp directory, but ensure path structure matches what `getConfigPath()` expects

---

### 2026-01-17: Step 2a - State Machine

- Pure state machine with no I/O makes testing straightforward
- Used TypeScript discriminated unions for DaemonEvent type - provides good type safety
- InvalidTransitionError custom error class helps with debugging and programmatic error handling
- The `canTransition` method allows checking validity without throwing
- Event emitter pattern using Set<Listener> and returning unsubscribe function is clean
- Context object is immutable (getter returns copy) to prevent accidental mutations
- 34 unit tests covering all valid transitions, invalid transitions, error handling, context tracking, and event emitter

---

### 2026-01-17: Step 2b - Unix Socket Server & IPC

- Node.js `net` module works well for Unix sockets - use `createServer()` for server and `connect()` for client
- JSON newline-delimited protocol is simple and effective for IPC
- PID file management: Check if PID is running with `process.kill(pid, 0)` - returns without error if process exists
- Socket permissions: Use `chmodSync(socketPath, 0o600)` for owner read/write only
- Stale file cleanup must happen before binding to socket, otherwise EADDRINUSE
- TypeScript: Socket `data` event can receive `Buffer | string`, need to handle both types
- Signal handlers: Use `process.on("SIGTERM/SIGINT")` for graceful shutdown
- Server lifecycle: Important to clean up clients, socket file, and PID file on shutdown
- Test isolation: Use `XDG_STATE_HOME` env var pointing to temp directory with unique PID suffix
- 30 new tests covering socket server, JSON protocol, commands, PID management, and cleanup

### 2026-01-17: Step 3a - Socket Client

- Socket client uses `connect()` from `node:net` to connect to Unix socket
- Quick fail by checking socket file exists before attempting connection - saves time when daemon not running
- Custom error classes (DaemonNotRunningError, ConnectionTimeoutError) help with user-friendly error messages
- Socket error codes: ECONNREFUSED and ENOENT both indicate daemon not running
- Response buffering: Accumulate data chunks until newline found, then parse JSON
- Timeout handling with `setTimeout()` and cleanup function to avoid resource leaks
- Toggle command needs two round trips: status to check current state, then start or stop
- Test isolation: Same pattern as server tests - use XDG_STATE_HOME with temp directory
- Testing timeout: Create mock server that accepts connections but never responds
- 18 new tests covering client connection, command sending, error handling, and response formatting

### 2026-01-17: Step 3b - Daemon Auto-Start

- Spawn daemon using `spawn()` with `detached: true` and `stdio: ["ignore", "ignore", "ignore"]` for clean background process
- Added `DaemonStartError` custom error class for spawn/startup failures
- `isDaemonStarting()` check prevents race condition when multiple commands try to start daemon simultaneously
- `waitForDaemon()` polls with configurable timeout until daemon responds to ping
- `ensureDaemonRunning()` is the main entry point - returns boolean indicating if daemon was auto-started
- CLI commands now auto-start daemon transparently using `ensureDaemonRunning()` before sending commands
- TypeScript: Need to use `stdio: ["ignore", "ignore", "ignore"]` (array form) instead of `stdio: "ignore"` (string form) to avoid type errors with spawn
- TypeScript: Need to check `process.argv[1]` for undefined before using
- 8 new tests covering waitForDaemon, ensureDaemonRunning, spawnDaemon, and DaemonStartError

### 2026-01-17: Step 4 - Audio Recording

- Created `src/audio/recorder.ts` with `AudioRecorder` class wrapping parecord subprocess
- Custom error classes: `ParecordNotFoundError` (with install instructions for Arch/Ubuntu/Fedora), `RecordingError`
- parecord args: `--file-format=wav --rate=16000 --channels=1 --format=s16le` for 16kHz mono WAV
- Device selection: Use `--device=` arg when config device is not "default"
- Temp files stored in XDG cache directory (`~/.cache/whispertui/recording-<timestamp>.wav`)
- Recording timeout protection: `setTimeout()` auto-stops after max duration (default 5 minutes)
- Graceful shutdown: SIGTERM to parecord, with SIGKILL fallback after 2 seconds
- `abort()` method for canceling without saving (SIGKILL + file cleanup)
- File validation: Check file exists and has content after stop, reject empty files
- Integrated recording into `DaemonServer` - start/stop commands now trigger actual audio recording
- DaemonServerOptions pattern: Accept config to extract recording settings, or provide recordingConfig directly
- Duck-typing for backward compatibility: Check if argument has `state` and `send` to detect StateMachine vs options object
- `cleanupOldRecordings()` helper to prune old temp files from cache directory
- 26 new tests covering recorder lifecycle, error handling, config extraction, and cleanup

### 2026-01-17: Step 5 - Groq API Integration

- Created `src/transcription/groq.ts` with `GroqClient` class for Whisper transcription
- Custom error classes: `MissingApiKeyError`, `TranscriptionApiError`, `InvalidAudioError`
- API key handling: Check config `api_key_env` for env var name, then read from `process.env`
- Direct API key support: Can pass `apiKey` directly to bypass env var lookup
- Groq API uses multipart/form-data with `FormData` and `Blob` for file upload
- Model: `whisper-large-v3` with JSON response format
- Request timeout with `AbortController` and configurable timeout (default 60s)
- Retry logic with exponential backoff for retryable errors (429, 5xx, network errors)
- Non-retryable errors: 401, 400 - fail immediately with descriptive messages
- Audio file validation: Check file exists, non-empty, at least 44 bytes (WAV header size)
- Integrated transcription into `DaemonServer.handleStop()` - transcribes after recording stops
- `extractTranscriptionConfig()` helper extracts config from app Config object
- Mocking fetch in Bun tests: Use `mock()` with cast `as unknown as typeof fetch` to satisfy TypeScript
- 30+ new tests covering client creation, API key handling, transcription, error handling, and retries

### 2026-01-17: Step 6a - Clipboard Output

- Created `src/output/clipboard.ts` with `copyToClipboard()` function using wl-copy
- Custom error classes: `WlCopyNotFoundError` (with install instructions for Arch/Ubuntu/Fedora), `ClipboardError`
- wl-copy reads from stdin - write text to process.stdin then close
- Empty text is handled gracefully (copies empty string to clear clipboard)
- Special characters (quotes, brackets, unicode) handled correctly by piping through stdin
- `checkWlCopyAvailable()` helper to verify wl-copy is installed
- Integrated clipboard copy into `DaemonServer.handleStop()` - copies text after successful transcription
- Clipboard errors are logged but don't fail the transcription - text still available in lastTranscription
- Updated `formatResponse()` in client to show transcription text and "(Copied to clipboard)" message
- 13 new tests covering clipboard operations, error handling, and integration with wl-paste verification

### 2026-01-17: Step 6b - Auto-Type Output

- Created `src/output/typer.ts` with `typeText()` function using wtype subprocess
- Custom error classes: `WtypeNotFoundError` (with install instructions), `TyperError`
- wtype uses stdin mode with `-` argument to receive text to type
- Delay option supported with `-d` flag for milliseconds between keystrokes
- Empty text handled gracefully (returns immediately without starting wtype)
- Added `checkWtypeAvailable()` helper - wtype doesn't have --version, so we check via --help
- Added `OutputConfig` interface with `autoPaste` and `pasteMethod` fields
- Added `extractOutputConfig()` function to extract output settings from Config
- Integrated output handling into `DaemonServer.handleStop()` with new `handleOutput()` method
- Output flow: Always copy to clipboard first (as fallback), then try wtype if configured
- wtype failure falls back silently to clipboard - text is still available
- Config option `paste_method: "wtype" | "clipboard-only"` controls behavior
- 12 new tests covering typer module and error handling

### 2026-01-17: Step 7 - Notifications

- Created `src/notify/index.ts` with `sendNotification()` function using notify-send subprocess
- Custom error classes: `NotifySendNotFoundError` (with install instructions for Arch/Ubuntu/Fedora), `NotificationError`
- `NotificationOptions` interface supports: title, body, urgency (low/normal/critical), timeout, icon, appName
- Urgency maps directly to notify-send `--urgency` flag
- Timeout specified in milliseconds maps to `--expire-time`
- `checkNotifySendAvailable()` helper to verify notify-send is installed
- `Notifier` class wraps notification sending with config awareness:
  - Respects `enabled` config option - silently skips if disabled
  - Caches notify-send availability check - only checks once
  - All notification methods are best-effort - errors logged but not thrown
- Convenience methods on Notifier: `notifyRecordingStarted()`, `notifyTranscriptionComplete(text)`, `notifyError(message)`
- `notifyTranscriptionComplete()` truncates text preview to 100 chars with "..." suffix
- `extractNotificationConfig()` extracts notification config from app Config object
- Integrated notifications into `DaemonServer`:
  - Recording started notification sent in `handleStart()`
  - Transcription complete notification sent after successful transcription
  - Error notifications sent for: recording failures, transcription failures, clipboard failures, wtype failures
  - wtype failure notification includes "(text available in clipboard)" when clipboard succeeded
- Config schema already had `notifications.enabled` defined from earlier work
- 31 new tests covering notification module and Notifier class

### 2026-01-17: Step 8 - History Storage

- Created `src/history/index.ts` with history management functions and `HistoryManager` class
- History entries stored as timestamped text files in `~/.local/share/whispertui/history/`
- Filename format: `YYYY-MM-DD_HH-MM-SS-mmm-nnn.txt` (timestamp + counter for uniqueness)
- Counter ensures unique filenames even when multiple saves occur in same millisecond
- `HistoryEntry` interface: id, timestamp (ISO 8601), text, path
- Functions: `saveHistory()`, `listHistory()`, `countHistory()`, `pruneHistory()`, `deleteHistory()`, `getHistory()`, `clearHistory()`
- `listHistory()` returns entries in reverse chronological order (newest first)
- Supports limit and offset options for pagination
- `pruneHistory()` deletes oldest entries when exceeding max_entries
- `HistoryManager` class wraps functions with config awareness:
  - Respects `enabled` config option - returns null if disabled
  - Auto-prunes on save when exceeding maxEntries
- Integrated into `DaemonServer.handleStop()` - saves transcription after successful output
- CLI `history` command displays recent transcriptions with timestamps
- Supports `--limit N` and `-n N` flags to limit output
- `extractHistoryConfig()` extracts history settings from app Config
- 38 new tests covering all history functions and HistoryManager class

### 2026-01-17: Step 9 - Context Detection

- Created `src/context/hyprland.ts` with Hyprland context detection via hyprctl
- Custom error classes: `HyprctlNotFoundError`, `HyprctlError`
- `getActiveWindow()` uses `hyprctl activewindow -j` for JSON output
- Handles empty/null output when no window is focused
- `checkHyprctlAvailable()` uses `hyprctl version` to verify installation
- `isCodeAwareApp()` does case-insensitive substring matching against config list
- `ContextDetector` class wraps detection with config awareness:
  - Respects `enabled` config option - returns null if disabled
  - Caches hyprctl availability check - only checks once
  - `detectContext()` is best-effort - returns null on any error
- `extractContextConfig()` extracts context settings from app Config
- Integrated into `DaemonServer.handleStart()`:
  - Detects context in background after state transition
  - Uses `setWindowContext()` on state machine
  - Context detection failure doesn't affect recording
- Context is included in status response via `getSnapshot().context`
- Config already had `context.enabled` and `context.code_aware_apps` from earlier work
- Default code-aware apps: Alacritty, kitty, foot, nvim, code, Code
- 21 new tests covering hyprctl wrapper, isCodeAwareApp, ContextDetector class

### 2026-01-17: Step 10 - TUI Foundation (Ink Setup)

- Added `ink` (v6.6.0) and `react` (v19.2.3) as dependencies
- Added `@types/react` and `ink-testing-library` as dev dependencies
- Created `src/ui/components/RecordingIndicator.tsx`:
  - Displays state label with color-coded icon (idle=gray/○, recording=red/●, transcribing=yellow/◐)
  - Blinking effect for recording state (500ms interval)
  - Spinner animation for transcribing state (150ms interval, rotates ◐◓◑◒)
- Created `src/ui/App.tsx`:
  - Main TUI application component using Ink
  - Polls daemon status every 500ms to stay in sync
  - Handles keyboard input: Enter (toggle), s (start when idle), Space (stop), q (quit)
  - Shows current window context if available
  - Displays last transcription preview (truncated to 60 chars)
  - Shows error messages when they occur
  - Disconnected state shows waiting message when daemon not available
- Created `src/ui/index.tsx`:
  - Entry point that ensures daemon is running before launching TUI
  - Exports `launchTui()` function for CLI integration
- Wired `tui` command in `src/index.ts` to call `launchTui()`
- Testing approach:
  - Used `ink-testing-library` for component testing
  - `skipDaemon` prop allows testing without actual daemon connection
  - Tests verify rendering, state display, and keyboard shortcuts
  - 20 new tests across RecordingIndicator and App components
- tsconfig.json already had `jsx: "react-jsx"` configured

### 2026-01-17: Step 11 - TUI History Browser

- Created `src/ui/components/History.tsx` with scrollable list of transcription entries
- History component features:
  - Displays entries in reverse chronological order (newest first)
  - Shows timestamp and truncated text preview for each entry
  - Selection indicator (▶) shows current selection
  - Scroll indicators show "more above/below" when list exceeds viewport
- Navigation: Arrow keys (↑/↓), vim-style (j/k), Page Up/Down, Home/End (g/G)
- Search/filter functionality:
  - Press `/` or `f` to enter filter mode
  - Type to filter entries (case-insensitive substring match)
  - Press Enter to apply filter, Escape to cancel and clear
  - Press `c` to clear active filter
  - Shows match count and filter text in header
- Selection: Press Enter to copy selected entry to clipboard via wl-copy
- Back navigation: Press `q` or Escape to return to main view
- Integrated into App.tsx with view mode switching:
  - Added `ViewMode` type ("main" | "history")
  - Press `h` in main view to switch to history
  - History entries loaded from `listHistory()` on view switch
  - Copy message shown for 2 seconds after copying
- Added `mockHistory` prop to App for testing without filesystem access
- Added `initialView` prop for testing history view directly
- 29 new tests covering History component and App integration
- Total: 338 tests passing

### 2026-01-17: Step 12a - Doctor Command

- Created `src/doctor/index.ts` with dependency checking functions
- `DependencyCheck` interface: name, description, status (ok/missing/error), version, installHint, required
- `EnvVarCheck` interface for environment variable checks
- Individual check functions for each dependency: checkBun, checkParecord, checkWlCopy, checkWtype, checkNotifySend, checkHyprctl
- Each check function uses spawn to run version commands and parses output
- `runCommand()` helper to execute commands and capture stdout/stderr/exit code
- `checkGroqApiKey()` checks for env var presence (doesn't expose actual value)
- `runDoctorChecks()` runs all checks in parallel with Promise.all
- Returns `DoctorResult` with allOk (all pass) and requiredOk (required only pass)
- Formatting functions with ANSI color codes: green checkmark for ok, red X for missing, yellow ! for error
- Install hints include package manager commands for Arch, Ubuntu/Debian, Fedora
- Optional dependencies marked with [optional] tag in output
- CLI wired up with `doctor` command in src/index.ts
- Exit code 1 if required dependencies missing, 0 otherwise
- parecord version parsing: extract first line only (pacat outputs multi-line)
- wtype has no --version flag, uses --help to detect presence
- hyprctl version parsing: extracts Tag or version number from output
- 25 new tests covering all check functions and formatting
- Total: 363 tests passing

---

## Current State

- Project status: Step 12a complete
- Last completed task: Step 12a - Doctor Command
- Current blockers: None

---

## Notes for Next Iteration

- Next task: Step 12b - Hyprland Integration & Polish
- Create Hyprland startup script
- Document keybind configuration in README
- Add `config --edit` command to open config in $EDITOR
- Final error handling review
- Add graceful degradation for missing optional dependencies
